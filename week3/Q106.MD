# 106. 从中序与后序遍历序列构造二叉树
> https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

``` python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder == [] or postorder == []:
            return None

        #先找出root节点
        root = postorder[-1]
        root = TreeNode(root)
        #把postorder最后一个数拿出来:因为是root
        #如果事前序遍历 则 preorder.index(preorder[0])
        post_last_index = postorder.index(postorder[-1])
        #把root节点在inorder中找出index ->可以区分左子树与右子树
        mid_index = inorder.index(root.val)
        #递归找寻左子树与右子树
        root.left = self.buildTree(inorder[:mid_index],postorder[:mid_index])
        root.right = self.buildTree(inorder[mid_index+1:],postorder[mid_index:post_last_index])

        return root
```